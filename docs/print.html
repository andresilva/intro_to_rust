<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="background.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="background/what_is_rust.html"><strong aria-hidden="true">1.1.</strong> What is Rust?</a></li><li class="chapter-item expanded "><a href="background/why_rust1.html"><strong aria-hidden="true">1.2.</strong> Why Rust? (I)</a></li><li class="chapter-item expanded "><a href="background/why_rust2.html"><strong aria-hidden="true">1.3.</strong> Why Rust? (II)</a></li><li class="chapter-item expanded "><a href="background/systems_programming_language.html"><strong aria-hidden="true">1.4.</strong> Systems Programming Language</a></li><li class="chapter-item expanded "><a href="background/runs_blazingly_fast.html"><strong aria-hidden="true">1.5.</strong> Runs Blazingly Fast</a></li><li class="chapter-item expanded "><a href="background/prevents_almost_all_crashes.html"><strong aria-hidden="true">1.6.</strong> Prevents Almost All Crashes</a></li><li class="chapter-item expanded "><a href="background/eliminates_data_races.html"><strong aria-hidden="true">1.7.</strong> Eliminates Data Races</a></li><li class="chapter-item expanded "><a href="background/problem.html"><strong aria-hidden="true">1.8.</strong> Problem</a></li></ol></li><li class="chapter-item expanded "><a href="whos_using_rust.html"><strong aria-hidden="true">2.</strong> Who's Using Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="whos_using_rust/mozilla.html"><strong aria-hidden="true">2.1.</strong> Mozilla</a></li><li class="chapter-item expanded "><a href="whos_using_rust/parity.html"><strong aria-hidden="true">2.2.</strong> Parity</a></li></ol></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">3.</strong> Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ownership/transferring_ownership.html"><strong aria-hidden="true">3.1.</strong> Transferring Ownership</a></li><li class="chapter-item expanded "><a href="ownership/transitivity.html"><strong aria-hidden="true">3.2.</strong> Transitivity</a></li></ol></li><li class="chapter-item expanded "><a href="borrowing.html"><strong aria-hidden="true">4.</strong> Borrowing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="borrowing/moving.html"><strong aria-hidden="true">4.1.</strong> Moving</a></li><li class="chapter-item expanded "><a href="borrowing/nesting.html"><strong aria-hidden="true">4.2.</strong> Nesting</a></li><li class="chapter-item expanded "><a href="borrowing/cloning.html"><strong aria-hidden="true">4.3.</strong> Cloning</a></li></ol></li><li class="chapter-item expanded "><a href="memory_management.html"><strong aria-hidden="true">5.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="mutability.html"><strong aria-hidden="true">6.</strong> Mutability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutability/borrow_mutability.html"><strong aria-hidden="true">6.1.</strong> Borrow Mutability</a></li><li class="chapter-item expanded "><a href="mutability/owned_mutability.html"><strong aria-hidden="true">6.2.</strong> Owned Mutability</a></li></ol></li><li class="chapter-item expanded "><a href="golden_rules.html"><strong aria-hidden="true">7.</strong> Golden Rules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="golden_rules/what_you_get.html"><strong aria-hidden="true">7.1.</strong> What you get</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">8.</strong> Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concurrency/concurrency_in_rust.html"><strong aria-hidden="true">8.1.</strong> Concurrency in Rust</a></li><li class="chapter-item expanded "><a href="concurrency/communication.html"><strong aria-hidden="true">8.2.</strong> Communication</a></li><li class="chapter-item expanded "><a href="concurrency/memory_safety.html"><strong aria-hidden="true">8.3.</strong> Memory Safety</a></li></ol></li><li class="chapter-item expanded "><a href="language_constructs.html"><strong aria-hidden="true">9.</strong> Language Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language_constructs/generics.html"><strong aria-hidden="true">9.1.</strong> Generics</a></li><li class="chapter-item expanded "><a href="language_constructs/traits.html"><strong aria-hidden="true">9.2.</strong> Traits</a></li><li class="chapter-item expanded "><a href="language_constructs/algebraic_data_types.html"><strong aria-hidden="true">9.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="language_constructs/no_hidden_states.html"><strong aria-hidden="true">9.4.</strong> No Hidden States</a></li><li class="chapter-item expanded "><a href="language_constructs/testing_and_documentation.html"><strong aria-hidden="true">9.5.</strong> Testing and Documentation</a></li></ol></li><li class="chapter-item expanded "><a href="breaking_the_rules.html"><strong aria-hidden="true">10.</strong> Breaking The Rules</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">11.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/development.html"><strong aria-hidden="true">11.1.</strong> Development</a></li><li class="chapter-item expanded "><a href="tooling/compatibility.html"><strong aria-hidden="true">11.2.</strong> Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="performance.html"><strong aria-hidden="true">12.</strong> Performance</a></li><li class="chapter-item expanded "><a href="pain_points.html"><strong aria-hidden="true">13.</strong> Pain Points</a></li><li class="chapter-item expanded "><a href="conclusion.html"><strong aria-hidden="true">14.</strong> Conclusion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conclusion/long_term_viability.html"><strong aria-hidden="true">14.1.</strong> Long-term Viability</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="links.html">Links</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<h3><a class="header" href="#safe-systems-programming" id="safe-systems-programming">Safe systems programming</a></h3>
<p><img src="./img/rust.svg" alt="" /></p>
<hr />
<blockquote>
<p>Andr√© Silva <a href="https://github.com/andresilva">@andresilva <img src="./img/github.png" alt="" /></a></p>
<p>Software Engineer @ <a href="https://parity.io">Parity Technologies</a></p>
</blockquote>
<blockquote>
<p><strong>Disclaimer:</strong></p>
<p>Most of the content here is taken from Alex Crichton's 2014 Rust Talk <a href="https://www.youtube.com/watch?v=agzf6ftEsLU"><img src="./img/youtube.png" alt="" /></a>, with code snippets updated to work with Rust 1.48.0</p>
<p>This presentation is forked from <a href="https://github.com/azriel91/intro_to_rust">https://github.com/azriel91/intro_to_rust</a>.</p>
</blockquote>
<h1><a class="header" href="#what-is-rust" id="what-is-rust">What is Rust?</a></h1>
<blockquote>
<p>Rust is a <strong>systems programming</strong> language that runs blazingly <strong>fast</strong>, <strong>prevents</strong> almost all <strong>crashes</strong>, and <strong>eliminates data races</strong>.</p>
<p><a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;hello, {}&quot;, &quot;world!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#why-rust" id="why-rust">Why Rust?</a></h1>
<p>Control vs Safety spectrum:</p>
<!-- This monstrosity is a hack to get a gradient bar without uploading an image -->
<p><span style="float: left;">C/C++</span>
<span style="float: right; margin-right: 5px;">Python</span></p>
<div style="clear: both;" />
<div style="
    height: 20px;
    background: linear-gradient(to right, red, yellow);
    border-radius: 4px 8px;
    border: 1px solid grey;">&nbsp;</div>
<span style="float: left;">More control, less safety</span><span style="float: right;">Less control, more safety</span>
<div style="clear: both;" /><br/>
<div style="
    border-radius: 5px 20px;
    text-align: center;
    background: linear-gradient(#009911, #22cc44);
    border: 1px solid grey;">
    <br />
    <b>Rust</b><br />
    More control, more safety<br />
    <br />
</div>
<h1><a class="header" href="#why-rust-ii" id="why-rust-ii">Why Rust? (II)</a></h1>
<p><img src="background/../img/more_control_more_safety.png" alt="" /></p>
<h1><a class="header" href="#systems-programming-language" id="systems-programming-language">Systems Programming Language</a></h1>
<ul>
<li>Fine grained control over allocations</li>
<li>No required garbage collector</li>
<li>Minimal runtime</li>
<li>&quot;Close to the metal&quot;</li>
</ul>
<h1><a class="header" href="#runs-blazingly-fast" id="runs-blazingly-fast">Runs Blazingly Fast</a></h1>
<ul>
<li>Compiles to an executable binary</li>
<li>LLVM backend <sup><a href="https://www.quora.com/What-is-LLVM-and-how-it-is-different-from-GCC">?</a></sup></li>
<li>LLVM's suite of optimizations</li>
<li>Competitive with C/C++</li>
</ul>
<h1><a class="header" href="#prevents-almost-all-crashes" id="prevents-almost-all-crashes">Prevents Almost All Crashes</a></h1>
<ul>
<li><em>Safe by default</em></li>
<li>Sophisticated type system and analysis</li>
<li>No segfaults</li>
<li>No null pointers</li>
<li>No dangling pointers</li>
</ul>
<h1><a class="header" href="#eliminates-data-races" id="eliminates-data-races">Eliminates Data Races</a></h1>
<ul>
<li><em>Ownership</em> guarantees</li>
<li><em>Borrowing</em> prevents dangling pointers</li>
<li>Strong, safe abstractions</li>
</ul>
<h1><a class="header" href="#problem" id="problem">Problem</a></h1>
<p><img src="background/../img/chromium.png" alt="" /></p>
<blockquote>
<p>‚ÄúAround 70% of our high severity security bugs are memory unsafety problems
(that is, mistakes with C/C++ pointers). Half of those are use-after-free
bugs.‚Äù - <a href="https://www.chromium.org/Home/chromium-security/memory-safety">Chromium project</a></p>
</blockquote>
<pre><code class="language-c">typedef struct Dummy { int a; int b; } Dummy;

void foo(void) {
    Dummy *ptr = (Dummy *) malloc(sizeof(struct Dummy));
    Dummy *alias = ptr;
    free(ptr);
    int a = alias.a; // use after free
    free(alias); // double free
}
</code></pre>
<h2><a class="header" href="#solved-by-managed-languages" id="solved-by-managed-languages">Solved by managed languages</a></h2>
<h3><a class="header" href="#java-python-ruby-c-scala-go" id="java-python-ruby-c-scala-go">Java, Python, Ruby, C#, Scala, Go...</a></h3>
<ul>
<li>Restrict direct access to memory</li>
<li>Run-time management of memory via periodic garbage collection</li>
<li>No explicit malloc and free, no memory corruption issues</li>
<li>But...
<ul>
<li>Overhead of tracking object references</li>
<li>Program behavior unpredictable due to GC (bad for real-time systems)</li>
<li>Limited concurrency (global interpreter lock typical)</li>
<li>Larger code size</li>
<li>VM must often be included</li>
<li>Needs more memory and CPU power (i.e. not baremetal)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#requirements-for-system-programs" id="requirements-for-system-programs">Requirements for system programs</a></h3>
<ul>
<li>Must be fast and have minimal runtime overhead</li>
<li>Should support direct memory access, but be memory-safe</li>
</ul>
<h1><a class="header" href="#whos-using-rust" id="whos-using-rust">Who's Using Rust</a></h1>
<h3><a class="header" href="#rust-is-using-rust" id="rust-is-using-rust">Rust is using Rust</a></h3>
<p>Makeup of code in the Rust repository (12 Dec 2020):</p>
<ul>
<li>Rust 94.4%</li>
<li>HTML 3.3%</li>
<li>Python 0.5%</li>
<li>JavaScript 0.4%</li>
<li>Makefile 0.3%</li>
<li>Shell 0.3%</li>
<li>Other 0.8%</li>
</ul>
<h1><a class="header" href="#mozilla" id="mozilla">Mozilla</a></h1>
<h2><a class="header" href="#servo" id="servo">Servo</a></h2>
<p><img src="whos_using_rust/../img/servo.png" alt="" /></p>
<ul>
<li>Experimental browser engine with a focus on performance and concurrency</li>
<li>Developed to take advantage of the memory safety properties and concurrency
features of the Rust programming language</li>
</ul>
<h2><a class="header" href="#firefox" id="firefox">Firefox</a></h2>
<ul>
<li>Several components developed as part of Servo have been integrated into
Firefox continuously:
<ul>
<li><a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">A parallelized CSS Style engine that can speed page load times and improve
stability</a></li>
<li><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/">A Paint engine, called WebRender, that moves drawing almost entirely to
GPUs, ensuring high frame rates and freeing up the CPU to do other
work</a></li>
<li>MP4 metadata parser</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#parity" id="parity">Parity</a></h1>
<ul>
<li>One of the early adopters of Rust (circa 2016)</li>
<li>Working on decentralized software</li>
<li>Building performance-critical networked applications</li>
<li>More than a million lines of Rust code written</li>
</ul>
<h3><a class="header" href="#main-projects" id="main-projects">Main projects</a></h3>
<ul>
<li><a href="https://github.com/openethereum/openethereum">OpenEthereum</a>
<ul>
<li>Fast and feature-rich multi-network Ethereum client</li>
</ul>
</li>
<li><a href="https://github.com/libp2p/rust-libp2p">rust-libp2p</a>
<ul>
<li>A network stack for peer-to-peer enabled applications</li>
</ul>
</li>
<li><a href="https://github.com/paritytech/substrate">Substrate</a>
<ul>
<li>A next-generation framework for building blockchain-based applications</li>
</ul>
</li>
<li><a href="https://github.com/paritytech/polkadot">Polkadot</a>
<ul>
<li>Polkadot is a network protocol that allows arbitrary data - not just
tokens - to be transferred across blockchains</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#ownership" id="ownership">Ownership</a></h1>
<p>Variables are <em>moved</em> to new locations, preventing the previous location from using it</p>
<p>There is only every <em>one</em> owner of data!</p>
<h2><a class="header" href="#problem-1" id="problem-1">Problem</a></h2>
<p>A common mistake in C:</p>
<pre><code class="language-c++">int main() {
    int *slot = malloc(sizeof(int));
    *slot = 3;
    helper(slot);
    helper(slot); // use after free!
}

void helper(int *slot) {
    printf(&quot;The number was: %d\n&quot;, *slot);
    free(slot);
}
</code></pre>
<pre><code class="language-c++">a.out(62940,0x7fff7b9ea310) malloc: *** error for object 0x7fecb0c03b10:
pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
zsh: abort      ./a.out
</code></pre>
<p>Rust's way of representing this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slot = Box::new(3);
    helper(slot); // moves the value!
    helper(slot); // error: use of moved value
}

fn helper(slot: Box&lt;i32&gt;) {
    println!(&quot;The number was: {}&quot;, slot);
}
</code></pre></pre>
<h1><a class="header" href="#transferring-ownership" id="transferring-ownership">Transferring Ownership</a></h1>
<pre><pre class="playground"><code class="language-rust">fn helper() -&gt; Box&lt;i32&gt; {
    let three = Box::new(3);
    return three; // transfer ownership
}

fn main() {
    // acquire ownership of return value
    let my_three = helper();

    println!(&quot;my_three: {}&quot;, my_three);
}
</code></pre></pre>
<h1><a class="header" href="#transitivity" id="transitivity">Transitivity</a></h1>
<p>Ownership is a <em>deep</em> property of a type</p>
<pre><pre class="playground"><code class="language-rust">struct A { b: B }
struct B { c: Box&lt;i32&gt; }

fn main() {
    let a: A = A { b: B { c: Box::new(2) } };
    let c = a.b.c;

    let b: B = a.b; // error! (moved by `c`)
}
</code></pre></pre>
<h1><a class="header" href="#borrowing" id="borrowing">Borrowing</a></h1>
<p>Owned values can be <em>borrowed</em> in Rust to allow usage for a certain period of time.</p>
<pre><pre class="playground"><code class="language-rust">// The `&amp;` sigil means &quot;borrowed reference&quot;
fn helper(_slot: &amp;Vec&lt;i32&gt;) { /* ... */ }

fn main() {
    let a = Vec::new();

    // doesn't move!
    helper(&amp;a);
    helper(&amp;a);
}
</code></pre></pre>
<h2><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h2>
<p>Borrowed values are only valid for a particular <em>lifetime</em></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: &amp;i32;
    {
        let b = 3;
        a = &amp;b; // error! `b` does not live long enough
    }
    
    println!(&quot;a: {}&quot;, a);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = 3;
    let a: &amp;i32;
    a = &amp;b; // ok, `b` has the same lifetime as `a`
    
    println!(&quot;a: {}&quot;, a);
}
</code></pre></pre>
<h1><a class="header" href="#moving" id="moving">Moving</a></h1>
<p>Borrowing prevents <em>moving</em></p>
<pre><pre class="playground"><code class="language-rust">fn work_with(_slot: Vec&lt;i32&gt;) { /* ... */ }

fn main() {
    let a = vec![1];
    let b = &amp;a;

    work_with(a); // error! borrowed by 'b'
    
    println!(&quot;b: {:?}&quot;, b);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn work_with(_slot: Vec&lt;i32&gt;) { /* ... */ }

fn main() {
    let a = Vec::new();
    
    {
        let b = &amp;a;
        println!(&quot;b: {:?}&quot;, b)
    }
    
    work_with(a); // ok
}
</code></pre></pre>
<h2><a class="header" href="#problem-2" id="problem-2">Problem</a></h2>
<p>A common mistake in C:</p>
<pre><code class="language-c">*int helper() {
    int a = 3;
    return &amp;a;
}

int main(int argc, char const *argv[]) {
    printf(&quot;%d\n&quot;, *helper());
    return 0;
}
</code></pre>
<p>Rust's way of representing this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Your number was: {}&quot;, *helper());
}

fn helper&lt;'a&gt;() -&gt; &amp;'a i32 {
    let a = 3;
    return &amp;a;
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Your number was: {}&quot;, *helper(&amp;3));
}

fn helper&lt;'a&gt;(value: &amp;'a i32) -&gt; &amp;'a i32 {
    return value;
}
</code></pre></pre>
<h1><a class="header" href="#nesting" id="nesting">Nesting</a></h1>
<p>Borrows can be nested:</p>
<ul>
<li>Someone can borrow something you are borrowing.</li>
<li>Someone can borrow part of the thing you are borrowing.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct MyStruct { inner: i32 }

fn do_print(value: &amp;i32) {
    println!(&quot;value: {}&quot;, *value);
}

fn print(s: &amp;MyStruct) {
    do_print(&amp;s.inner);
}

fn main() {
    let s = MyStruct { inner: 3 };
    print(&amp;s);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct MyStruct { inner: i32 }

fn get(s: &amp;MyStruct) -&gt; &amp;i32 {
    &amp;s.inner
}

fn main() {
    let s = MyStruct { inner: 3 };
    let inner = get(&amp;s); // same lifetime as `s`
    println!(&quot;inner: {}&quot;, inner);

    // essentially the same as
    let inner = &amp;s.inner;
    println!(&quot;inner: {}&quot;, inner);
}
</code></pre></pre>
<h1><a class="header" href="#cloning" id="cloning">Cloning</a></h1>
<p>Borrowed values can become owned values through <em>cloning</em>.</p>
<p>Cloning is to make a deep duplicate of the memory of the borrowed value.</p>
<pre><pre class="playground"><code class="language-rust">fn clone_vector(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    v.clone()
}

fn main() {
    let mut v1 = vec![1, 2, 3];
    let v2 = clone_vector(&amp;v1);

    v1[0] = 0;

    println!(&quot;v1: {:?}&quot;, v1);
    println!(&quot;v2: {:?}&quot;, v2);
}
</code></pre></pre>
<h1><a class="header" href="#memory-management" id="memory-management">Memory Management</a></h1>
<p>Rust has fine-grained memory management, but is automatically managed once created.</p>
<p>Each variable has a <em>scope</em> it is valid for, and it is automatically deallocated when it goes out of scope.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // `slot` is an *owned* value
    let slot = Box::new(3);
    // The slot goes out of scope here, it is free'd
}
</code></pre></pre>
<h2><a class="header" href="#reference-counting" id="reference-counting">Reference Counting</a></h2>
<p>Reference counting is another way of managing memory.</p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;

fn main() {
    let data = Rc::new(3);          // reference count of 1
    {
        let data2 = data.clone();   // reference count of 2
        work_with(data2);           // transfer ownership of `data2`
    }                               // reference count of 1
    work_with(data);                // transfer ownership of `data`
}                                   // reference count of 0, memory deallocated

fn work_with(data: Rc&lt;i32&gt;) {
    println!(&quot;data: {}&quot;, data);
}
</code></pre></pre>
<p>This allows multiple structs to <em>own</em> a reference to the same chunk of memory. This is useful for sharing a 'context' object between processors, for example ‚Äî one processor may add information to the context which allows other processors to reason over it.</p>
<h1><a class="header" href="#mutability" id="mutability">Mutability</a></h1>
<p>Values are <em>immutable</em> by default in Rust, and must be tagged as being <em>mutable</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 4;
a = 5; // error!
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 4;
a = 5; // ok
<span class="boring">}
</span></code></pre></pre>
<p>Mutability is also a part of the type of a borrowed pointer.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inc(i: &amp;i32) {
    *i += 1; // error!
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inc(i: &amp;mut i32) {
    *i += 1; // ok
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#borrow-mutability" id="borrow-mutability">Borrow Mutability</a></h1>
<p>Borrowed pointers may coerce:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = &amp;mut 1;
let b: &amp;usize = a; // ok
let c: &amp;mut usize = b; // error!
<span class="boring">}
</span></code></pre></pre>
<p>Values can be <em>frozen</em> by borrowing</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = Vec::new();
{
    let b = &amp;a; // freezes `a`
    a.push(1);  // error!
    
    println!(&quot;b: {:?}&quot;, b);
}
a.push(2); // ok
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#owned-mutability" id="owned-mutability">Owned Mutability</a></h1>
<p>Mutability propagates deeply into owned types</p>
<pre><pre class="playground"><code class="language-rust">struct A { b: B }

struct B { c: usize }

fn main() {
    let mut a = A { b: B { c: 2 } };
    a.b.c = 3;
    a.b = B { c: 4 };
    a = A { b: B { c: 5 } };

    let frozen = a;
    frozen.b.c = 4; // error!
}
</code></pre></pre>
<h1><a class="header" href="#golden-rules" id="golden-rules">Golden Rules</a></h1>
<h2><a class="header" href="#the-holy-grail-of-rust" id="the-holy-grail-of-rust">The holy grail of Rust</a></h2>
<p>Learn these rules, and they will serve you well.</p>
<ul>
<li>You can't keep borrowing something after it stops existing</li>
<li>One object may have many immutable references to it (<code>&amp;T</code>)</li>
<li><strong>OR</strong> exactly one mutable reference (<code>&amp;mut T</code>) (not both)</li>
<li>That's it!</li>
</ul>
<p><img src="./img/holy_grail.jpg" alt="" /></p>
<ul>
<li>TLDR: Aliasing <strong>XOR</strong> Mutability</li>
</ul>
<h1><a class="header" href="#what-you-get-out-of-it" id="what-you-get-out-of-it">What you get out of it</a></h1>
<h2><a class="header" href="#iterator-invalidation" id="iterator-invalidation">Iterator invalidation</a></h2>
<ul>
<li>Iterator invalidation due to mutating a collection you're iterating over</li>
<li>This pattern can be written in C, C++, Java, Python, Javascript...
<ul>
<li>But may result in, e.g, <code>ConcurrentModificationException</code> (at runtime!)</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vs = vec![1, 2, 3, 4];
for v in &amp;vs {
    vs.pop();
    // ERROR: cannot borrow `vs` as mutable because
    // it is also borrowed as immutable
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-after-free" id="use-after-free">Use-after-free</a></h2>
<ul>
<li>Valid in C/C++ and a common source of errors</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y: &amp;i32;
{
    let x = 5;
    y = &amp;x; // error: `x` does not live long enough
}
println!(&quot;{}&quot;, *y);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#resource-leak" id="resource-leak">Resource leak</a></h2>
<ul>
<li>Never forget to close a file or a socket ever again</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::prelude::*;

fn main() -&gt; std::io::Result&lt;()&gt; {
    {
        let mut file = File::create(&quot;foo.txt&quot;)?;
        file.write_all(b&quot;Hello, world!&quot;)?;
        // file is automatically closed here
    } 
    
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h1>
<h2><a class="header" href="#what-is-concurrency" id="what-is-concurrency">What is concurrency</a></h2>
<ul>
<li>One program with multiple threads of execution running at the same time</li>
<li>Threads can share data without communication overhead
<ul>
<li>(networking, inter-process communication channels, etc)</li>
</ul>
</li>
<li>Threads are more lightweight than individual processes
<ul>
<li>No large OS context switch when switching between threads</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#why-is-concurrency-hard" id="why-is-concurrency-hard">Why is concurrency hard</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* thread 1 */ let mut y = &amp;mut x;
/* thread 1 */ *y = 1;
/* thread 1 */ println!(&quot;{}&quot;, *y); // foo expects 1
               // =&gt; 1
/* thread 2 */ let mut z = &amp;mut x;
/* thread 2 */ *z = 2;
/* thread 2 */ println!(&quot;{}&quot;, *z); // bar expects 2
               // =&gt; 2
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>Sharing data: What if two threads try to write to the same piece of data at
the same time?</li>
<li>Data races: The behavior of the same piece of code might change depending on
when exactly it executes</li>
<li>Synchronization: How can I be sure all of my threads see the correct world
view?</li>
<li>Deadlock: How can you safely share resources across threads and ensure threads
don't lock each other out of data access?</li>
</ul>
<h1><a class="header" href="#concurrency-in-rust" id="concurrency-in-rust">Concurrency in Rust</a></h1>
<p>Using ownership to prevent data races.</p>
<p>Parallelism is achieved at the granularity of an OS thread.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn expensive_computation() {
    println!(&quot;expensive start&quot;);
    thread::sleep(Duration::from_millis(500));
    println!(&quot;expensive end&quot;);
}

fn other_expensive_computation() {
    println!(&quot;other_expensive start&quot;);
    thread::sleep(Duration::from_millis(500));
    println!(&quot;other_expensive end&quot;);
}

fn main() {
    // Spawn a child thread to be run in parallel
    thread::spawn(|| {
        expensive_computation();
    });

    other_expensive_computation();
}
</code></pre></pre>
<h1><a class="header" href="#communication" id="communication">Communication</a></h1>
<p>Threads can communicate with channels</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn expensive_computation() -&gt; i32 {
    thread::sleep(Duration::from_millis(500));
    123
}

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send(expensive_computation()).expect(&quot;Failed to send result&quot;);
    });

    // Do some work in the meantime

    let answer = rx.recv().expect(&quot;Failed to receive result&quot;);
    println!(&quot;answer: {}&quot;, answer);
}
</code></pre></pre>
<h1><a class="header" href="#memory-safety" id="memory-safety">Memory Safety</a></h1>
<p>Safety is achieve by requiring that a <code>closure</code> owns captured variables.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = Vec::new();

// spawn a thread and move ownership of 'a' into it
::std::thread::spawn(move || {
    a.push(&quot;foo&quot;);
});

a.push(&quot;bar&quot;); // error!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#sharing-memory" id="sharing-memory">Sharing Memory</a></h2>
<p>Tasks can also share memory:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::Arc;
use std::thread;

fn main() {
    let mut map = HashMap::new();
    map.insert(&quot;tomato&quot;, &quot;red&quot;);
    map.insert(&quot;celery&quot;, &quot;green&quot;);
    map.insert(&quot;carrot&quot;, &quot;orange&quot;);

    let arc1 = Arc::new(map);
    let arc2 = arc1.clone();

    let t1 = thread::spawn(move || println!(&quot;Celery is `{}`&quot;, arc1[&quot;celery&quot;]));
    let t2 = thread::spawn(move || println!(&quot;Carrots are `{}`&quot;, arc2[&quot;carrot&quot;]));

    t1.join().unwrap();
    t2.join().unwrap();
}
</code></pre></pre>
<h1><a class="header" href="#language-constructs" id="language-constructs">Language Constructs</a></h1>
<h2><a class="header" href="#primitives" id="primitives">Primitives</a></h2>
<ul>
<li><strong>Booleans</strong>: are true and false</li>
<li><strong>Integers</strong>: are both signed and unsigned. u8/i8, u16/i16, u32/i32, u64/i64, and u128/i128</li>
<li><strong>Floating point numbers</strong>: f32 and f64</li>
<li><strong>Tuples</strong>: are for grouping different types together (i32, f64, i8)</li>
<li><strong>Arrays</strong>: that are fixed size [u32; 3] is the type of [1, 2, 3]</li>
<li><strong>References</strong>: like pointers but safer. &amp;i32 is the type of &amp;5</li>
<li><strong>Slices</strong>: refer to parts of an array &amp;[u8]</li>
<li><strong>char</strong>: is a single Unicode Scalar Value, and uses single quotes 'ü¶Ä'</li>
<li><strong>&amp;str</strong>: is an immutable UTF-8 string &quot;this is a crab: ü¶Ä&quot;</li>
</ul>
<h2><a class="header" href="#structs" id="structs">Structs</a></h2>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: usize,
    y: usize,
}

fn main() {
    let p = Point { x: 1, y: 2 };
}
</code></pre></pre>
<h2><a class="header" href="#tuples" id="tuples">Tuples</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let pair = (2, 3);
    let (first, second) = pair;
    println!(&quot;pair: {:?}&quot;, pair);
    println!(&quot;first: {:?}, second: {:?}&quot;, first, second);
}
</code></pre></pre>
<h2><a class="header" href="#enums" id="enums">Enums</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Circle,
    Square
}

fn test(shape: Shape) {
    match shape {
        Circle =&gt; { /* ... */ }
        Square =&gt; { /* ... */ }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#pointers" id="pointers">&quot;&amp;Pointers&quot;</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 1;
let a: &amp;i32 = &amp;value;               // never null!
let b: Option&lt;&amp;i32&gt; = Some(&amp;value); // may be null

// represented as a null pointer
let c: Option&lt;&amp;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>Any <code>&amp;mut</code> pointer is the <em>only</em> pointer to its data</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;

let b = &amp;mut a; // ok
let c = &amp;mut a; // error!
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyVec&lt;T&gt; { /* */ }

impl&lt;T&gt; MyVec&lt;T&gt; {
  pub fn find&lt;P&gt;(&amp;self, predicate: P) -&gt; Option&lt;&amp;T&gt;
    where P: Fn(&amp;T) -&gt; bool
  {
    for v in self {
      if predicate(v) {
        return Some(v);
      }
    }
    None
  }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Mul {
    fn mul(self, other: Self) -&gt; Self;
}

#[derive(Debug)]
struct Rational(usize, usize);

impl Mul for Rational {
    fn mul(self, other: Self) -&gt; Self {
        Rational(self.0 * other.0, self.1 * other.1)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#traits-in-generics" id="traits-in-generics">Traits in generics</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Mul {
</span><span class="boring">   fn mul(self, other: Self) -&gt; Self;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rational(usize, usize);
</span><span class="boring">
</span><span class="boring">impl Mul for Rational {
</span><span class="boring">   fn mul(self, other: Self) -&gt; Self {
</span><span class="boring">       Rational(self.0 * other.0, self.1 * other.1)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl Mul for usize {
    fn mul(self, other: Self) -&gt; Self {
        self * other
    }
}

fn mul&lt;N: Mul&gt;(n1: N, n2: N) -&gt; N {
    n1.mul(n2)
}

println!(&quot;{:?}&quot;, mul(1, 2)); // =&gt; 2
println!(&quot;{:?}&quot;, mul(Rational(1, 2), Rational(1, 2))); // =&gt; Rational(1, 4)
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#algebraic-data-types" id="algebraic-data-types">Algebraic Data Types</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
  Some(T),
  None,
}

let my_vec = vec![0, 1, 2, 3, 4, 5];
let x = match my_vec.into_iter().find(|n| *n &gt;= 2) {
    Some(2) =&gt; { 'a' },
    Some(n) if n &gt; 10 =&gt; { 'b' },
    None =&gt; { 'c' },
};

println!(&quot;x: {}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>Fixed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_vec = vec![0, 1, 2, 3, 4, 5];
let x = match my_vec.into_iter().find(|n| *n &gt;= 2) {
    Some(2) =&gt; { 'a' },
    Some(n) if n &gt; 10 =&gt; { 'b' },
    _ =&gt; { 'c' },
};

println!(&quot;x: {}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#no-hidden-states" id="no-hidden-states">No hidden states</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
  Some(T),
  None,
}

enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}

<span class="boring">let mut my_vec = vec![1, 2, 3, 42].into_iter();
</span>
// v is Option&lt;&amp;T&gt;, not &amp;T -- cannot use without checking for None
let v = my_vec.find(|t| *t &gt;= 42);

if let Some(v) = v {
    println!(&quot;v: {:?}&quot;, v);
}

// n is Result&lt;i32, ParseIntError&gt; -- cannot use without checking for Err
let n = &quot;42a&quot;.parse::&lt;i32&gt;();

match n {
    Ok(n) =&gt; println!(&quot;n: {}&quot;, n),
    Err(err) =&gt; println!(&quot;failed with error: {:?}&quot;, err),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#testing-and-documentation" id="testing-and-documentation">Testing and Documentation</a></h1>
<p>Built-in testing support and docs.</p>
<h3><a class="header" href="#tests" id="tests">Tests</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_pop_empty_stack() {
    let stack = Vec::&lt;u32&gt;::new();
    assert!(stack.pop() == None);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>running 1 test
test test_pop_empty_stack ‚Ä¶ ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_pop_empty_stack() {
    let mut stack = Vec::&lt;u32&gt;::new();
    stack.push(3);
    assert!(stack.pop() == None);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>running 1 test
test test_pop_empty_stack ‚Ä¶ FAILED

--- test_pop_empty_stack stdout ---
          thread ‚Äòtest_pop_empty_stack‚Äô panicked at ‚Äòassertion failed: stack.pop() == None‚Äô, test.rs: 4

failures:
     test_pop_empty_stack

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

</code></pre>
<h3><a class="header" href="#documentation-with-tests" id="documentation-with-tests">Documentation (with tests!)</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Removes the last element from a vector and returns it, or None if it is empty.
///
/// # Examples
///
/// ```
/// let stack = Vec::&lt;u32&gt;::new();
/// assert!(stack.pop() == None);
/// ```
fn pop(&amp;mut self) -&gt; Option&lt;Box&lt;T&gt;&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>running 1 test
test test_pop_empty_stack_0 ‚Ä¶ ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#breaking-the-rules" id="breaking-the-rules">Breaking The Rules</a></h1>
<h2><a class="header" href="#unsafe-blocks" id="unsafe-blocks"><code>unsafe</code> Blocks</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 3;

    // Turn off some compiler checks,
    // &quot;I know what I'm doing&quot;
    unsafe {
        let b = &amp;a as *const i32 as *mut i32;
        *b = 4;
    }

    println!(&quot;{}&quot;, a); // prints 4
}
</code></pre></pre>
<h2><a class="header" href="#transmuting" id="transmuting">Transmuting</a></h2>
<p>Transforming the mutability of a variable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn transmute&lt;T, U&gt;(t: T) -&gt; U {
    /* ... */
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Invalid promotion to a mutable pointer
let a: &amp;usize = &amp;3;
let b: &amp;mut usize = unsafe { std::mem::transmute(a) };
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#foreign-function-interface-ffi" id="foreign-function-interface-ffi">Foreign Function Interface (FFI)</a></h2>
<p><em>All</em> FFI is unsafe</p>
<pre><pre class="playground"><code class="language-rust">extern {
    fn write(fd: i32, data: *const u8, len: usize) -&gt; i32;
}

fn main() {
    let data = b&quot;Hello, world!\n&quot;;

    unsafe {
        write(1, &amp;data[0], data.len());
    }
}
</code></pre></pre>
<h3><a class="header" href="#fast-ffi" id="fast-ffi">Fast FFI</a></h3>
<pre><code class="language-asm">main:
  ...
  xorl    %edi, %edi
  leaq    _str1365(%rip), %rsi
  movl    $0xd, %edx
  callq   0x100000eb2 ## symbol stub for: _write
</code></pre>
<h1><a class="header" href="#tooling" id="tooling">Tooling</a></h1>
<p>Rust has great tools for different parts of a project.</p>
<ul>
<li><strong>Development:</strong> Writing code, dependency management</li>
<li><strong><a href="https://doc.rust-lang.org/book/testing.html">Testing</a>:</strong> Unit, integration,
<a href="https://doc.rust-lang.org/book/benchmark-tests.html">benchmarking</a> - are all
integrated into the native tools. Other user created tools like
<a href="https://github.com/BurntSushi/cargo-benchcmp">benchcmp</a> and
<a href="https://github.com/SimonKagstrom/kcov">kcov</a> exist for additional quality
checks</li>
<li><strong>Releasing:</strong> Building, Publishing</li>
<li><strong>Code Documentation:</strong> Markdown comments with inline code that <em>actually
runs</em> (<a href="https://doc.rust-lang.org/std/">std</a>, <a href="https://docs.rs/">docs.rs</a>)</li>
<li><strong>User Documentation:</strong> Guides can be written in markdown and web pages
automatically generated for publishing
(<a href="https://github.com/azerupi/mdBook">mdbook</a>)</li>
</ul>
<h1><a class="header" href="#development" id="development">Development</a></h1>
<h2><a class="header" href="#meta" id="meta">Meta</a></h2>
<p><a href="https://www.rustup.rs/">Rustup</a> is the version manager for different Rust
versions. This lets you easily switch between <code>stable</code>, <code>beta</code>, and <code>nightly</code>
versions of Rust, as well as update each version.</p>
<h2><a class="header" href="#cargo" id="cargo">Cargo</a></h2>
<p>Rust comes bundled with a tool called <code>cargo</code>, which handles project generation,
building, and dependency management. It also manages 3rd party commands
(download, build, run).</p>
<h2><a class="header" href="#code-formatting" id="code-formatting">Code Formatting</a></h2>
<p><a href="https://github.com/rust-lang-nursery/rustfmt">Rustfmt</a> provides autoformatting
for code, so it makes it easy to both report and enforce a coding style.</p>
<h2><a class="header" href="#dependency-management" id="dependency-management">Dependency Management</a></h2>
<p>A published Rust library is called a crate, and the global repository for
published crates is <a href="https://crates.io/">crates.io</a>.</p>
<p>Dependencies are specified in a <code>Cargo.toml</code> file, and resolved dependency
versions are recorded in <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;my_lib&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Azriel Hoh&quot;]

[dependencies]
uuid = &quot;0.5.0&quot;

[dev-dependencies]
time = &quot;0.1.37&quot;
</code></pre>
<h2><a class="header" href="#linting" id="linting">Linting</a></h2>
<p><a href="https://github.com/rust-lang/rust-clippy">Clippy</a> provides a collection of
lints to catch common mistakes and improve your Rust code. Currently boasts
more than 400 lints.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if x == true {
    // do something
}

//  warning: equality checks against true are unnecessary
//   --&gt; src/main.rs:4:8
//   |
// 4 |     if x == true {
//   |        ^^^^^^^^^ help: try simplifying it as shown: `x`

let i = 0;
while i &gt; 10 {
    println!(&quot;let me loop forever!&quot;);
}

// error: variables in the condition are not mutated in the loop body
//  --&gt; src/main.rs:9:11
//   |
// 9 |     while i &gt; 10 {
//   |           ^^^^^^
//   |
//   = note: this may lead to an infinite or to a never running loop
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ide" id="ide">IDE</a></h2>
<p>There is basic IDE support for a number of editors:</p>
<ul>
<li>Eclipse</li>
<li>Visual Studio</li>
<li>IntelliJ IDEA</li>
<li>GNOME Builder</li>
</ul>
<p>Editor plugins:</p>
<ul>
<li>Emacs</li>
<li>Vim</li>
<li>Sublime Text</li>
<li>Atom</li>
<li>Visual Studio Code</li>
</ul>
<p>These when linked up with <code>rust-analyzer</code>, provide:</p>
<ul>
<li>Inline warning and error highlighting</li>
<li>Autocompletion</li>
<li>Jump to definition</li>
</ul>
<p>The current status of IDE support can be seen at
<a href="https://areweideyet.com/">areweideyet.com</a>.</p>
<h1><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h1>
<p>Rust uses LLVM, normal calling conventions, no runtime, DWARF, so:</p>
<ul>
<li>Works with all traditional tools
<ul>
<li>gdb/lldb works</li>
<li>valgrind works</li>
<li>LLVM sanitizers work</li>
<li>Linux: perf works</li>
<li>macOS: Instruments works</li>
<li>Windows: Whatever's used, it probably works (maybe!)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#performance" id="performance">Performance</a></h1>
<h2><a class="header" href="#the-computer-language-benchmarks-game" id="the-computer-language-benchmarks-game">The Computer Language Benchmarks Game</a></h2>
<p>The Computer Language Benchmarks Game is a free software project for comparing
how a given subset of simple algorithms can be implemented in various popular
programming languages. </p>
<p><img src="./img/benchmark-game1.svg" alt="" />
<img src="./img/benchmark-game2.svg" alt="" /></p>
<h2><a class="header" href="#techempower-web-framework-benchmarks" id="techempower-web-framework-benchmarks">TechEmpower Web Framework Benchmarks</a></h2>
<p>This project provides representative performance measures across a wide field of
web application frameworks across different programming languages and
frameworks. The current tests exercise plaintext responses, JSON serialization,
database reads and writes via the object-relational mapper (ORM), collections,
sorting, server-side templates, and XSS counter-measures.</p>
<p><img src="./img/tech-empower.png" alt="" /></p>
<h2><a class="header" href="#environment-friendly-software" id="environment-friendly-software">Environment friendly software</a></h2>
<p><img src="./img/greta.jpg" alt="" /></p>
<h1><a class="header" href="#pain-points" id="pain-points">Pain Points</a></h1>
<ul>
<li>Learning curve
<ul>
<li>The borrow checker is different</li>
<li>No object-oriented programming</li>
</ul>
</li>
<li>Ecosystem
<ul>
<li>Young, and few maintainers</li>
<li>Small (but growing quickly)</li>
</ul>
</li>
<li>No runtime
<ul>
<li>No runtime reflection</li>
<li>No runtime-aided debugging</li>
</ul>
</li>
<li>Compilation speed
<ul>
<li>Improving, but still slow</li>
<li>No pre-built libraries</li>
</ul>
</li>
<li>Windows
<ul>
<li>Full compiler/std support</li>
<li>Limited library support</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<h2><a class="header" href="#what-rust-is-good-at" id="what-rust-is-good-at">What Rust Is Good At</a></h2>
<ul>
<li>Large scale maintainable systems</li>
<li>Embedding into other languages</li>
<li>Fearless low-level systems programming and concurrency</li>
<li><em>Fast</em>, <em>correct</em> code</li>
</ul>
<h2><a class="header" href="#should-you-use-rust" id="should-you-use-rust">Should You Use Rust?</a></h2>
<p>YES.</p>
<p><strong>Should you use Rust <em>now</em>?</strong></p>
<p>YES.</p>
<h1><a class="header" href="#status" id="status">Status</a></h1>
<ul>
<li>Language and standard library are stable</li>
<li>There are crates for just about anything</li>
<li>Recently added <code>async/await</code> support making it even more ergonomic to write
asynchronous code</li>
<li>It is fun!</li>
</ul>
<h1><a class="header" href="#long-term-viability-seems-high" id="long-term-viability-seems-high">Long-term viability seems high</a></h1>
<ul>
<li>Most loved language four years running
<ul>
<li><a href="https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/">https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/</a></li>
</ul>
</li>
<li>Adoption by large companies (‚ÄúFriends of Rust‚Äù):
<ul>
<li>Mozilla, Dropbox, CloudFlare, Microsoft, Google, Amazon, Facebook, Atlassian, npm</li>
</ul>
</li>
<li>Great interoperability story; easy incremental adoption</li>
<li>Increased company involvement in Rust itself</li>
<li>~10 yearly conferences around the world</li>
</ul>
<h1><a class="header" href="#links" id="links">Links</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust book</a></li>
<li><a href="https://www.rust-lang.org">rust-lang.org</a></li>
<li><a href="https://github.com/rust-lang/rust">github.com/rust-lang/rust</a></li>
<li><a href="https://reddit.com/r/rust">reddit.com/r/rust</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
